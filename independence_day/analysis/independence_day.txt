The first thing to do is to identify the various ships present on the grid. This can be done by first setting empty cells to -1 and full cells to -2, then going through the grid – every time we hit a -2,  we floodfill from that location using breadth-first-search, setting all adjacent -2’s to the current number of ships. We then increase the number of ships and keep going. In the end, we’ll have a grid of integers ranging from -1 to the number of ships-1.

Now, we simulate each snatch, finding the number of unique ships partially covered by it and adding onto a running total. However, simulating each snatch completely separately would take a bit too long, so we need to use the many overlaps present among snatches to our advantage. So, we do each row of snatches at a time.

For each row, we go through the snatches left-to-right. We keep a counter for each ship number, which keeps track of the number of cells with that ship number found in the current snatch. We also keep a counter of the number of distinct ships found in the current snatch. All these counters start at 0. For the first snatch, we simply go through all S*S cells, updating the counters as we go, giving us the number of ships in this snatch. For the next snatch over, everything is the same, except one column at the left is lost, and an extra column at the right is added. We go through each of these columns, updating the counters, and we get the number of ships found in this snatch. This process is repeated until the right-most snatch, at which point we go to the next row and start over.

Once we have a total number of ships among all the snatches, we simply divide this by the number of snatches (which can be found easily), and we’re done. In total, this algorithm has a runtime of around O(N3).
